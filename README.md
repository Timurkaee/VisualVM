JVM. Организация памяти, сборщики мусора, VisualVM

Класс JvmComprehension загружается с помощью класс-лоадера в память JVM.

int i = 1;
Создается переменная i типа int в области памяти стека.
Присваивается значение 1 переменной i.

Object o = new Object();
Создается переменная o типа Object в области памяти стека.
Вызывается конструктор класса Object, создается новый объект Object в области памяти heap.
Переменная o получает ссылку на созданный объект Object в heap.

Integer ii = 2;
Создается переменная ii типа Integer в области памяти стека.
Создается объект Integer с значением 2 в области памяти heap.
Переменная ii получает ссылку на созданный объект Integer в heap.

printAll(o, i, ii);
Вызывается статический метод printAll.
Создается новый фрейм в стеке для метода printAll.
Передаются значения аргументов: ссылка на объект o, значение i, ссылка на объект ii.

5)Integer uselessVar = 700;
Создается переменная uselessVar типа Integer в области памяти стека.
Создается объект Integer с значением 700 в области памяти heap.
Переменная uselessVar получает ссылку на созданный объект Integer в heap.

System.out.println(o.toString() + i + ii);
Вызывается метод toString() у объекта o.
Вызывается метод Integer.toString(i) для преобразования i в строку.
Вызывается метод Integer.toString(ii) для преобразования ii в строку.
Выполняется конкатенация полученных строк и выводится на экран.

System.out.println(“finished”);
Выводится на экран строка “finished”.

В данном коде все созданные объекты (класс Object и объекты Integer) станут недостижимыми после завершения работы метода printAll, так как на них не останется ссылок. Таким образом, сборщик мусора автоматически освободит память, занимаемую этими объектами.
